<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK" />
<title>面试题集</title>
<script type="text/javascript" src="../other/jquery-1.7.2.js"></script>
<script type="text/javascript" src="../other/css.js"/></script>
<style>
.table{
	width:100%;
	margin-left:-10px;
}
.table tr td{
	border:1px solid black;
	padding-left:10px;
}

.table2 tr td{
	border:1px solid black;
	text-align:left;
	padding-left:10px;
}


.style1 {
	color: #008000;
}

div{
	padding-left:3%;
}
.divfirst{
	width:96%;
	background-color:#FFCC99;
}
.divnext{
	border-style: dotted;
	border-color: #C0C0C0;
	display:none;
	width:94%;
	margin-left:1%;
}
</style>

</head>

<body>
<h2>数据库篇</h2>


<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
事务
</div>
<div class="divnext" >
<ul style=" list-style-type: decimal;">
	<li>
		原子性（Atomicity）<br/><br/>
		
		原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响<br/>
	</li>
	<li>
		一致性（Consistency）<br/><br/>
		一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。<br/>
	</li>
	<li>
		隔离性（Isolation）<br/><br/>
		隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

　　关于事务的隔离性数据库提供了多种隔离级别<br/>
	</li>
	<li>
		持久性（Durability）<br/><br/>
		持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误
		<br/>
	</li>
</ul>

</div>

<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
最左前缀原则
</div>
<div class="divnext" >
当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。
<br/>
mysql 与 oracle 有区别 oracle 有基于代价的优化器（CBO）
</div>

<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
https://www.cnblogs.com/fjdingsd/p/5273008.html
</div>
<div class="divnext">content
</div>



<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
test
</div>
<div class="divnext">content
</div>



</body>
</html>
